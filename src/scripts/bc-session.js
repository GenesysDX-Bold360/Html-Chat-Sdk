/** @namespace */
var bc = window.bc = (window.bc || {});

/**
 * An instance of {@link bc.Session}
 * @typedef {(object)} Session
 */

/**
 * @typedef {{chatId:string}|{secure:object}|{button:string}|{url:string}|{customUrl:string}} ChatParams
 * @typedef {{visitorId:string}} VisitorInfo
 */

/**
 * Main class for maintaining a session with a BoldChat window
 * @param {string} apiKey - The API key obtained from the BoldChat setup interface.
 * @param {ChatParams} [chatParams={}] - An object containing chat launch parameters. This is typically generated by BoldChat's visitor monitoring code.
 * @param {string} chatParams.[visitor] - Optional parameter with the ID for the visitor.  If this is null or undefined one will be generated by BoldChat's server.
 * @param {object} chatParams.[secure] - If using validated chat functionality, this parameter accepts the PGP or SHA-512 encrypted chat information. Leave undefined, or null otherwise.
 * @param {string} chatParams.[button] - Optional parameter indicating the button id that the chat was launched from.  This is usually only passed when chat is launched from Visitor Monitoring code.
 * @param {string} chatParams.[url] - Optional chat launch url.  This is usually only passed when chat is launched form Visitor Monitoring code.
 * @param {string} chatParams.[customUrl] - The custom url to display to the operator in the client. This is optional.
 * @param {VisitorInfo} [visitorInfo={}] - An object containing information about the visitor. This is typically generated by BoldChat's visitor monitoring code.
 * @param {string} visitorInfo.[reference] - Optional parameter
 * @param {string} visitorInfo.[information] - Optional parameter
 * @param {string} visitorInfo.[name] - Optional parameter
 * @param {string} visitorInfo.[phone] - Optional parameter
 * @param {string} visitorInfo.[email] - Optional parameter
 * @param {ViewManager} [viewManager] - The object that will receive method calls to update the chat window UI.  If this is null or undefined then a new instance of bc.ViewManager will be used.
 * @constructor
 */
bc.Session = function(apiKey, chatParams, visitorInfo, viewManager) {
	var scope = this;
	var queuePosition = 0;
	var answerTimeout = null;
	var minimizeTimeout = null;
	var canAddMinimizeClass = false;
	var seenLastMessageId = 0;

	this.viewManager = viewManager;
	this.client = new bc.VisitorClient(apiKey);
	this.chatParams = chatParams || {};
	this.visitorInfo = visitorInfo || {};

	var failure = function(msg) {
		scope.viewManager.hideBusy();
		scope.viewManager.showError(msg);
	};


	/**
	 * Returns the api key that the Session was instantiated with.
	 * @returns {string} - The Api key
	 */
	this.getApiKey = function() {
		return apiKey;
	};

	/**
	 * Gets the visitor id for making api calls.
	 * @returns {string} - The visitor Id
	 */
	this.getVisitorId = function() {
		var loc = document.location.href;
		var visitorId = this.visitorInfo.visitorId;
		if(!visitorId) {
			var vrIndex = loc.indexOf('_bcvm_vrid_');
			if(vrIndex !== -1) {
				var vrEq = loc.indexOf('=', vrIndex);
				var vrEnd = loc.indexOf('&', vrIndex);
				if(vrEq !== -1) {
					visitorId = loc.substring(vrEq + 1, vrEnd === -1 ? loc.length : vrEnd);
				}
			}
		}
		return visitorId;
	};

	//noinspection Eslint
	/**
	 * Gets the availability for chat.
	 * @param {function} onChatAvailability - The callback with the availability status, 2 values will be passed, a boolean indicating availability, and if the boolean is false a string will be return with unavailable reason.
	 * @param {function} onChatAvailabilityFailed - The callback if the availability check fails.
	 */
	this.getChatAvailability = function(onChatAvailability, onChatAvailabilityFailed) {
		this.client.getChatAvailability(scope.getVisitorId())
			.success(function(data) {
				onChatAvailability(data.Available, data.UnavailableReason);
			})
			.failure(onChatAvailabilityFailed);
	};

	var displayUnavailableForm = function(response) {
		var introKey = 'api#unavailable#no_operators';
		var submitKey = 'api#chat#close';
		if(response.UnavailableForm) {
			if(response.UnavailableForm.Fields) {
				introKey = 'api#unavailable#intro';
				submitKey = 'api#chat#send';
			} else if(response.UnavailableReason === 'unsecure') {
				introKey = 'api#unsecure#message';
			}
		}
		scope.viewManager.showForm(introKey, response.UnavailableForm, null, submitKey, scope._unavailableFormSubmitted);
	};

	var addObjectValues = function(source, destination) {
		for(var prop in source) {
			if(source.hasOwnProperty(prop)) {
				destination[prop] = source[prop];
			}
		}
	};

	var displayWaitForOperatorMessage = function() {
		if(!scope.client.chatContainsStatusMessage) {
			var waitForOpMsg = null;
			if(queuePosition !== 0) {
				waitForOpMsg = scope.viewManager.getLocalizedValue('api#chat#operators_busy');
			} else {
				waitForOpMsg = scope.viewManager.getLocalizedValue('api#chat#waiting_for_operator');
			}
			if(waitForOpMsg) {
				scope.viewManager.showStatusMessage(waitForOpMsg);
			}
		}
	};

	var isChatQueued = function() {
		if(scope.client.isStarted()) {
			var chat = scope.client.getChat();
			// Chat will be null until it receives the first call to updateChat, so rely on the isStarted() value only
			// until it gets an update
			return chat === null || (!chat.Answered && !chat.Ended && !chat.Closed);
		}
	};

	var startAnswerTimeout = function(secondsToTimeout) {
		if(secondsToTimeout) {
			bc.util.log("Starting answer timeout for " + secondsToTimeout + " seconds");
			if(answerTimeout) {
				clearTimeout(answerTimeout);
				answerTimeout = null;
			}
			if(isChatQueued()) {
				answerTimeout = setTimeout(function() {
					bc.util.log("Answer timed out");
					if(isChatQueued()) {
						scope.cancelQueueWait();
					}
					answerTimeout = null;
				}, secondsToTimeout * 1000);
			}
		}
	};

	/**
	 * Initiates the start of a new session.
	 * @param {boolean} [skipPreChat] - Optional parameter to skip the pre-chat form for the chat session if it is enabled in the configuration.
	 * @param {string} [language] - Optional parameter to set the initial language of the chat window. For the default window language do not pass the parameter, or pass null.
	 * @param {object} [data] - The data parameter allows you to pre-set certain values of the chat that will be available to the operator.  For a full list of data keys consult the api documentation.
	 */
	this.startChat = function(skipPreChat, language, data) {
		if(!this.viewManager) {
			this.viewManager = new bc.ViewManager();
		}

		this.viewManager.initialize(this);
		scope.viewManager.showBusy();
		if(this.client.hasChatKey()) {
			this.client.startChat()
				.success(function(startData) {
					scope.viewManager.showChatForm();
					scope.viewManager.hideBusy();
					scope.chatParams = scope.client.getChatParams();
					scope.visitorInfo = scope.client.getVisitInfo();

					if(startData.Brandings || scope.client.getBrandings()) {
						scope.viewManager.setLocalizationValues(startData.Brandings || scope.client.getBrandings());
					}
					displayWaitForOperatorMessage();
				})
				.failure(function(error) {
					bc.util.log('Failed to resume previous chat session: ' + error, true);
					scope.viewManager.closeChat();
				});
		} else {
			var confirmIframeLoaded = setTimeout(function() {
				scope.client.setState('error');
				scope.viewManager.hideBusy();
				scope.viewManager.showError('Error creating chat, please try again.');	//localization would not yet have been loaded
			}, 15000);

			var chatDataParams = {};
			addObjectValues(visitorInfo, chatDataParams);
			addObjectValues(data, chatDataParams);
			chatDataParams.language = chatDataParams.language || scope.chatParams.language;

			this.client.createChat(scope.chatParams.visitor || scope.getVisitorId(), language || scope.chatParams.language, skipPreChat, chatDataParams, scope.chatParams.secure, scope.chatParams.button, scope.chatParams.url, scope.chatParams.customUrl)
				.success(function(chatData) {
					clearTimeout(confirmIframeLoaded);
					scope.viewManager.setLocalizationValues(chatData.Brandings);
					if(scope.chatParams) {
						scope.client.addChatParams(scope.chatParams);
					}
					if(scope.visitorInfo) {
						scope.client.addVisitInfo(scope.visitorInfo);
					}

					scope.viewManager.hideBusy();
					if(chatData.PreChat) {
						scope.viewManager.showForm('api#prechat#intro', chatData.PreChat, null, 'api#prechat#start', scope._preChatFormSubmitted);
					} else if(chatData.UnavailableForm) {
						displayUnavailableForm(chatData);
					} else {
						startAnswerTimeout(chatData.AnswerTimeout);
						scope.viewManager.showChatForm();
						displayWaitForOperatorMessage();
					}
				})
				.failure(function(msg) {
						clearTimeout(confirmIframeLoaded);
						failure(msg);
					}
				);
		}
	};

	/**
	 * Changes the language of the chat window to another language retrieving the language values from the BoldChat server.
	 * @param {string} language - The new language to use.
	 */
	this.setLanguage = function(language) {
		scope.viewManager.showBusy();
		this.client.changeLanguage(language)
			.success(function(data) {
				scope.viewManager.hideBusy();
				if(data.Brandings) {
					scope.viewManager.setLocalizationValues(data.Brandings);
				}
				if(data.Departments) {
					scope.viewManager.changeDepartments(data.Departments);
				}
			})
			.failure(failure);
	};

	/**
	 * Notify the server that the visitor is currently typing a message.
	 * @param {boolean} isTyping - true if the visitor is currently typeing, false if they are not.
	 */
	this.setVisitorTyping = function(isTyping) {
		this.client.visitorTyping(isTyping);
	};

	/**
	 * Send the visitor message to the BoldChat system.
	 * @param {string} message - The visitor message text
	 * @return {number} - Returns the message id assigned to this message. This should be used to reference the message later.
	 */
	this.addVisitorMessage = function(message) {
		var id = bc.util.getId();
		this.client.sendMessage(scope.getVisitorName(), message, id);
		return id;
	};

	/**
	 * Sets the email address to send a transcript of the chat to after the chat has ended.
	 * @param {string} emailAddress - The email address
	 */
	this.setEmailTranscript = function(emailAddress) {
		this.client.setEmailTranscript(emailAddress);
	};

	/**
	 * Should be called when the visitor chooses to cancel their wait in the queue.  This triggers an unavailable email form
	 * to be displayed.
	 */
	this.cancelQueueWait = function() {
		scope.viewManager.showBusy();

		scope.client.cancelChat();
		scope.client.getUnavailableForm()
			.success(function(data) {
				scope.viewManager.hideQueueMessage();
				scope.viewManager.clearOperatorTypers();
				scope.viewManager.hideBusy();
				displayUnavailableForm(data);
			})
			.failure(failure);
	};

	/**
	 * Ends the current chat session, this is ok to call even if the chat has already ended by the operator.  It will initiate the call
	 * to the server to retrieve the post-chat information if one is configured.
	 */
	this.endChat = function() {
		scope.viewManager.showBusy();
		scope.viewManager.hideChatInteraction();

		switch(scope.client.getState()) {
			case 'error':
			case 'prechat':
			case 'postchat':
			case 'unavailable':
				scope.client.finishChat();
				scope.viewManager.closeChat();
				scope.viewManager.hideForm();
				break;
			default:
				scope.client.finishChat()
					.success(function(data) {
						scope._processChatEndData(data);
					})
					.failure(function() {
						scope._processChatEndData();
					});
		}
	};

	/**
	 * Gets the name of the visitor
	 * @return {string} - The name of the visitor
	 */
	this.getVisitorName = function() {
		if(!scope.visitorInfo) {
			scope.visitorInfo = scope.client.getVisitInfo();
		}
		if(scope.visitorInfo) {
			return scope.visitorInfo.first_name || scope.visitorInfo.name || scope.visitorInfo.last_name;
		}
		return scope.viewManager.getLocalizedValue('api#generic#you');
	};

	/**
	 * Gets the name of the operator
	 * @return {string} - The name of the operator
	 */
	this.getOperatorName = function() {
		return scope.viewManager.getLocalizedValue('api#chat#operator');
	};

	/**
	 * Update chat callback from the server, this checks to see if the chat is answered, and if the chat has ended.
	 * @param {object} data - The data from the OSS message
	 * @private
	 */
	this._updateChat = function(data) {
		if(data.Values.Answered || data.Values.Ended) {
			scope.viewManager.hideStatusMessage();
		}
		if(data.Values.Ended) {
			scope.viewManager.hideChatInteraction();	//TODO: This gets invoked multiple times when a chat is ended... ineffecient
		}
	};

	/**
	 * Updates the operator is typing message
	 * @param {object} data - The data from the OSS message
	 * @private
	 */
	this._updateTyper = function(data) {
		if(data.Values.PersonType === bc.PersonType.Operator) {
			if(data.Values.IsTyping) {
				scope.viewManager.setOperatorTyping(data.Values.Name || scope.getOperatorName(), data.Values.ImageURL, data.PersonID);
			} else {
				scope.viewManager.hideOperatorTyping(data.PersonID);
			}
		}
	};

	/**
	 * The add message callback from the server. This adds system and operator messages to the history view.
	 * @param {object} data - The data from the OSS message
	 * @private
	 */
	this._addMessage = function(data) {
		var avatar = data.Values.ImageURL || scope.client.getPerson(data.Values.PersonID).Avatar;
		var name = data.Values.Name || scope.client.getPerson(data.Values.PersonID).Name || scope.getOperatorName();
		scope.viewManager.addOrUpdateMessage(data.MessageID, data.Values.PersonType, name, new Date(data.Values.Created), data.Values.Text, avatar, data.Values.IsReconstitutedMsg, data.Values.OriginalText);

		if(minimizeTimeout) {
			clearTimeout(minimizeTimeout);
			minimizeTimeout = null;
		}
		var lastMessageId = scope.client.getLastMessageId();
		if((canAddMinimizeClass && seenLastMessageId !== lastMessageId) || !lastMessageId) {
			minimizeTimeout = scope.viewManager.notifyMinimizeButton();
		}
		canAddMinimizeClass = lastMessageId === data.MessageID;
		if(canAddMinimizeClass) {
			seenLastMessageId = lastMessageId;	// This is required as when you refresh the page, the last message is sent twice from the server.
		}
	};

	/**
	 * Shows the auto messages in the chat interface.  This replaces any system messages currently being displayed as well as any existing auto messages.
	 * @param {object} data - The data from the OSS message
	 * @private
	 */
	this._autoMessage = function(data) {
		scope.client.chatContainsStatusMessage = true;
		scope.viewManager.showStatusMessage(data.Text);
	};

	/**
	 * Updates the busy message.
	 * @param {object} data - The data from the OSS message
	 * @private
	 */
	this._updateBusyQueue = function(data) {
		queuePosition = data.Position;
		if(data.Position <= 0) {
			scope.viewManager.hideQueueMessage();
		} else if(data && data.Position && data.Position > 0) {
			scope.viewManager.showOrUpdateQueueMessage(data.Position, data.UnavailableFormEnabled);
		}
		displayWaitForOperatorMessage();
	};

	/**
	 * Updates the visitor information with the values from the pre-chat form is applicable
	 * @param {VisitorInfo} [visitorInfo={}] - An object containing information about the visitor. This is typically generated by BoldChat's visitor monitoring code.
	 * @param {string} visitorInfo.[reference] - Optional parameter
	 * @param {string} visitorInfo.[information] - Optional parameter
	 * @param {string} visitorInfo.[name] - Optional parameter
	 * @param {string} visitorInfo.[phone] - Optional parameter
	 * @param {string} visitorInfo.[email] - Optional parameter
	 */
	var updateVisitorInfo = function(visitorInfo) {
		if(visitorInfo.name) {
			scope.visitorInfo.name = visitorInfo.name;
		} else if(visitorInfo.first_name) {
			scope.visitorInfo.name = visitorInfo.first_name;
		}
		if(visitorInfo.last_name) {
			scope.visitorInfo.last_name = visitorInfo.last_name;
		}
		if(visitorInfo.email) {
			scope.visitorInfo.email = visitorInfo.email;
		}
		if(visitorInfo.information) {
			scope.visitorInfo.information = visitorInfo.information;
		}
		if(visitorInfo.initial_question) {
			scope.visitorInfo.initial_question = visitorInfo.initial_question;
		}
		if(visitorInfo.language) {
			scope.visitorInfo.language = visitorInfo.language;
		}
		if(visitorInfo.phone) {
			scope.visitorInfo.phone = visitorInfo.phone;
		}
		scope.client.updateVisitInfo(scope.visitorInfo);
	};

	/**
	 * Called when a pre-chat form is submitted. A successful return call signals the start of an active chat session with an operator (or in a queue).
	 * @param {object} data - The form data in JSON format.
	 * @private
	 */
	this._preChatFormSubmitted = function(data) {
		scope.viewManager.hideForm();
		scope.viewManager.showBusy();

		updateVisitorInfo(data);
		scope.client.submitPreChat(data)
			.success(function(response) {
				scope.viewManager.hideBusy();
				if(response.UnavailableReason) {
					displayUnavailableForm(response);
				} else {
					startAnswerTimeout(response.AnswerTimeout);
					scope.viewManager.showChatForm();
					displayWaitForOperatorMessage();
				}
			})
			.failure(failure);
	};

	this._postChatFormSubmitted = function(data) {
		scope.viewManager.hideForm();
		scope.viewManager.showBusy();
		scope.viewManager.hideCloseButton();

		var formDef = null;
		scope.client.submitPostChat(data)
			.success(function() {
				'use strict';
				var itemsWithData = 0;
				for(var prop in data) {
					if(data[prop] && data.hasOwnProperty(prop)) {
						itemsWithData++;
					}
				}
				var titleKey = 'api#chat#ended';
				if(data.email && itemsWithData === 1) {
					titleKey = 'api#postchat#emailed';
					formDef = {Fields: [{'Key': 'email', 'Type': 'label', 'Value': data.email}]};
				} else if(data.email && itemsWithData > 1) {
					titleKey = 'api#postchat#submitted_and_emailed';
					formDef = {Fields: [{'Key': 'email', 'Type': 'label', 'Value': data.email}]};
				} else if(itemsWithData > 0) {
					titleKey = 'api#postchat#submitted';
				}
				scope.viewManager.hideBusy();
				scope.viewManager.showForm(titleKey, formDef, null, 'api#chat#close', function() {
					scope.viewManager.closeChat();
					scope.viewManager.hideForm();
				});
			})
			.failure(function(msg) {
				'use strict';
				failure(msg);
				scope.viewManager.closeChat();
				scope.viewManager.hideForm();
			});
	};

	/**
	 * Called when an unavailable email form is submitted. This signals the end of the chat session.
	 * @param {object} data - The form data in JSON format.
	 * @private
	 */
	this._unavailableFormSubmitted = function(data) {
		scope.viewManager.hideForm();
		if(data.email && data.subject && data.body) {
			scope.client.submitUnavailableEmail(data.email, data.subject, data.body)
				.success(function() {
					scope.viewManager.hideForm();
					scope.viewManager.hideCloseButton();
					scope.viewManager.showForm('api#unavailable#emailed', null, null, 'api#chat#close', function() {
						'use strict';
						scope.viewManager.closeChat();
						scope.viewManager.hideForm();
					});
				})
				.failure(function(msg) {
					'use strict';
					failure(msg);
					scope.viewManager.closeChat();
					scope.viewManager.hideForm();
				});
		} else {
			scope.viewManager.closeChat();
		}
	};

	this._chatEnded = function(data) {
		bc.util.log('session:this_chatEnded');
		scope.viewManager.hideChatInteraction();
		scope._processChatEndData(data);
	};

	this._chatEndedByOpSubmitted = function(data) {
		//hide operatorEndedMessage
		scope.viewManager.hideForm();
		scope.client.getPostChatFormIfAvail();
	};

	this._chatEndedByOp = function(data) {
		bc.util.log('session:this_chatEndeByOp');
		scope.viewManager.hideChatInteraction();
		scope.viewManager.showForm('api#chat#operator_ended', null, null, 'api#chat#close', scope._chatEndedByOpSubmitted, null, null, true);
	};

	this._processChatEndData = function(data) {
		scope.viewManager.hideBusy();
		if(data && data.PostChat) {
			//TODO: The intro is being displayed even though the form may be not be applicable (not enough chat interaction to qualify for post-chat form)
			var introKey = 'api#postchat#intro';
			var topFieldLocKey = 'api#email#transcript';
			if(data.PostChat.Fields && data.PostChat.Fields.length === 1 && data.PostChat.Fields[0].Key && data.PostChat.Fields[0].Key === 'email') {
				introKey = 'api#email#transcript';
				topFieldLocKey = null;
			}
			scope.viewManager.showForm(introKey, data.PostChat, null, 'api#postchat#done', scope._postChatFormSubmitted, null, topFieldLocKey, true);

		} else {
			scope.viewManager.showForm('api#chat#ended', null, null, 'api#chat#close', function() {
				scope.viewManager.closeChat();
				scope.viewManager.hideForm();
			}, null, null, true);
		}
	};

	this.minimizeChat = function() {
		clearTimeout(minimizeTimeout);
		scope.viewManager.minimizeChat();
	};

	this.changeMinimizedStatus = function(isMinimized) {
		scope.client.changeMinimizedStatus(isMinimized);
	};

	this.isMinimized = function() {
		return scope.client.isMinimized();
	};

	//this._emailChatHistory = function(data) {
	//	scope.viewManager.hideChatInteraction();
	//};

	this.client.updateChat(this._updateChat);
	this.client.updateTyper(this._updateTyper);
	this.client.autoMessage(this._autoMessage);
	this.client.updateBusy(this._updateBusyQueue);
	this.client.addMessage(this._addMessage);
	this.client.chatEnded(this._chatEnded);
	this.client.chatEndedByOp(this._chatEndedByOp);
	//this.client.emailChatHistory(this._emailChatHistory);

};
